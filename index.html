<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Jogo Hebraico Bíblico 3D – Rodrigo Niskier</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css?family=JetBrains+Mono:400,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+Hebrew:wght@400;700&display=swap">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body { font-family: 'JetBrains Mono', monospace; background: #222c36; }
    canvas#game { background: transparent; display: block; margin: 0 auto; touch-action: none; }
    .hebrew { font-family: 'Noto Sans Hebrew', sans-serif; font-size: 2.2rem; direction: rtl; }
    .modal-bg { background: rgba(0,0,0,0.7); }
    .slide-in { animation: slide-in 1.1s cubic-bezier(0.4,0,0.2,1);}
    @keyframes slide-in { from { transform: translateY(-30px); opacity:0; } to { transform: translateY(0); opacity:1; } }
    .char-choice { transition: transform 0.18s; }
    .char-choice.selected { transform: scale(1.13); border: 3px solid #2563eb; box-shadow: 0 0 0 4px #2563eb55; z-index: 2; }
    .lives-heart { color: #ff4141; font-size: 2rem; margin-right: 0.3em; }
    @media (max-width: 600px) { #game { margin-top: 10px !important; } }
  </style>
</head>
<body class="flex flex-col items-center min-h-screen bg-gray-900">

  <div id="startScreen" class="fixed inset-0 bg-gray-950 flex flex-col items-center justify-center z-50">
    <div class="bg-gray-100 rounded-2xl p-8 shadow-2xl flex flex-col items-center gap-6 w-[360px]">
      <h1 class="text-2xl font-bold text-gray-900 mb-2">Bem-vindo ao Jogo de Hebraico Bíblico 3D!</h1>
      <div class="flex flex-col gap-2 w-full">
        <label class="text-gray-800 font-semibold mb-1 text-base" for="username">Seu nome de jogador:</label>
        <input id="username" type="text" maxlength="18" autocomplete="off" class="w-full px-4 py-2 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500 text-lg text-gray-800" placeholder="Digite seu nome..."/>
      </div>
      <div class="w-full">
        <span class="font-semibold text-gray-800 mb-2 block">Escolha seu personagem:</span>
        <div class="flex flex-row gap-7 justify-center mt-1">
          <button id="char1" class="char-choice rounded-full border-2 border-gray-300 p-1 bg-white focus:outline-none">
            <img src="personagem1.png" alt="Personagem 1" class="w-20 h-20 object-cover rounded-full"/>
          </button>
          <button id="char2" class="char-choice rounded-full border-2 border-gray-300 p-1 bg-white focus:outline-none">
            <img src="personagem2.png" alt="Personagem 2" class="w-20 h-20 object-cover rounded-full"/>
          </button>
        </div>
      </div>
      <button id="playBtn" class="mt-2 w-full px-4 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow hover:bg-blue-700 transition text-lg disabled:bg-gray-300 disabled:text-gray-400 disabled:cursor-not-allowed" disabled>Play</button>
    </div>
  </div>

  <div id="commandScreen" class="fixed inset-0 bg-gray-900/90 flex flex-col items-center justify-center z-50 hidden">
    <div class="bg-white rounded-2xl shadow-2xl w-[340px] p-8 flex flex-col items-center gap-6">
      <h2 class="text-2xl font-bold text-blue-800 mb-2">Comandos do Jogo 3D</h2>
      <ul class="text-gray-900 text-base text-left leading-7 mb-3">
        <li><b>Movimentar:</b> <span class="bg-gray-200 rounded px-1">←</span> <span class="bg-gray-200 rounded px-1">→</span> (ou botões laterais)</li>
        <li><b>Pular:</b> <span class="bg-gray-200 rounded px-1">↑</span> (ou botão "↑")</li>
        <li><b>Atirar (Exemplo):</b> <span class="bg-gray-200 rounded px-1">barra de espaço</span></li>
        <li><b>Coletar palavra:</b> encoste nela</li>
      </ul>
      <button id="okBtn" class="w-full px-5 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow hover:bg-blue-700 transition">OK</button>
    </div>
  </div>

  <div id="scoreHud" class="fixed top-5 right-8 text-xl text-white z-20 flex items-center gap-7" style="display:none;">
    <div class="bg-gray-700 px-5 py-2 rounded-2xl shadow-lg font-bold flex items-center gap-2">Pontos: <span id="scoreValue">0</span></div>
    <div id="lives" class="flex items-center"></div>
  </div>

  <canvas id="game" width="900" height="440" class="rounded-2xl border-2 border-gray-800 shadow-2xl mt-10" style="display:none;"></canvas>

  <div id="touchControls" class="fixed left-0 bottom-0 w-full flex justify-between items-end px-6 pb-5 z-30" style="display:none;">
    <div class="flex gap-3">
      <button class="bg-gray-700/80 text-white rounded-full w-16 h-16 text-3xl flex items-center justify-center active:bg-blue-600" id="btnLeft" tabindex="-1">←</button>
      <button class="bg-gray-700/80 text-white rounded-full w-16 h-16 text-3xl flex items-center justify-center active:bg-blue-600" id="btnRight" tabindex="-1">→</button>
    </div>
    <div class="flex gap-3">
      <button class="bg-gray-700/80 text-white rounded-full w-16 h-16 text-3xl flex items-center justify-center active:bg-blue-600" id="btnUp" tabindex="-1">↑</button>
      <button class="bg-yellow-500 text-white rounded-full w-16 h-16 text-2xl flex items-center justify-center active:bg-yellow-600" id="btnFire" tabindex="-1">✝️</button>
    </div>
  </div>

  <div id="modal" class="fixed inset-0 flex items-center justify-center z-50 hidden">
    <div class="modal-bg absolute inset-0"></div>
    <div class="relative p-8 bg-gray-100 rounded-xl shadow-2xl w-[350px] slide-in">
      <div class="flex flex-col items-center gap-4">
        <span class="text-lg text-gray-900 font-semibold">Traduza a palavra:</span>
        <span id="hebrewWord" class="hebrew text-4xl text-gray-900"></span>
        <form id="answerForm" class="w-full flex flex-col gap-3 items-center">
          <input type="text" id="answerInput" autocomplete="off" placeholder="Digite a tradução..." class="w-full px-4 py-2 rounded-lg border-2 border-gray-300 focus:outline-none focus:border-blue-500 text-lg text-gray-800">
          <div class="flex flex-row gap-4 w-full justify-between items-center">
            <button type="button" id="hintBtn" class="px-3 py-1 bg-yellow-400 hover:bg-yellow-500 text-gray-900 font-bold rounded-lg transition">Dica</button>
            <button type="submit" class="px-5 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow hover:bg-blue-700 transition">Responder</button>
          </div>
        </form>
        <div id="feedback" class="text-base text-red-600 font-semibold mt-2 min-h-[28px]"></div>
        <div id="hint" class="text-gray-800 text-sm font-medium"></div>
        <div id="timer" class="text-gray-700 text-xs mt-1"></div>
      </div>
    </div>
  </div>

  <div id="endModal" class="fixed inset-0 flex items-center justify-center z-50 hidden">
    <div class="modal-bg absolute inset-0"></div>
    <div class="relative p-8 bg-white rounded-xl shadow-2xl w-[370px] slide-in text-center">
      <h2 id="endTitle" class="text-2xl text-blue-800 font-bold mb-4"></h2>
      <p id="endMsg" class="mb-2 text-lg"></p>
      <button onclick="window.location.reload()" class="mt-4 px-5 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow hover:bg-blue-700 transition">Jogar novamente</button>
    </div>
  </div>

<script>
// Unindo Parte 1 e Parte 2 do seu JavaScript original e adaptando para 3D

// ======== Utils ========
function isMobile() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
function normalize(str) {
  return str
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-zA-Z0-9ãõç\s]/g, '')
    .trim();
}

// ======== Tela Inicial & Comando (Lógica mantida) ========
let selectedChar = 0, playerName = "", usedHint = false;
const charBtns = [document.getElementById('char1'), document.getElementById('char2')];
function updatePlayBtnState() {
  document.getElementById('playBtn').disabled = !(playerName.length > 0 && selectedChar > 0);
}
charBtns.forEach((btn, idx) => {
  btn.addEventListener('click', () => {
    selectedChar = idx + 1;
    charBtns.forEach((b, j) => b.classList.toggle('selected', j === idx));
    updatePlayBtnState();
  });
});
document.getElementById('username').addEventListener('input', function() {
  playerName = this.value.trim();
  updatePlayBtnState();
});
document.getElementById('playBtn').addEventListener('click', function() {
  document.getElementById('startScreen').style.display = "none";
  document.getElementById('commandScreen').style.display = "flex";
});
document.getElementById('okBtn').addEventListener('click', function() {
  document.getElementById('commandScreen').style.display = "none";
  document.getElementById('game').style.display = ""; // Canvas será visível
  document.getElementById('scoreHud').style.display = "flex"; // HUD visível
  if (isMobile()) document.getElementById('touchControls').style.display = "flex";
  else document.getElementById('touchControls').style.display = "none";
  startGame(); // Inicia o jogo 3D
});

// ======== Palavras (Definições mantidas) ========
const charImgs = [ // Usaremos para texturas ou inspiração para modelos 3D depois
  "personagem1.png",
  "personagem2.png",
  "personagem3.png" // Para vilões
];
const backgroundImageUrl = "fundo.jpg"; // Poderia ser um skybox ou textura de fundo 3D
const WORDS = [
  {he:"בֵּן", tr:"ben", pt:["filho","menino","descendente"], dica:"Parentesco masculino"},
  {he:"בָּנִים", tr:"banim", pt:["filhos","meninos","descendentes"], dica:"Plural de filho"},
  {he:"אִשָּׁה", tr:"ishá", pt:["mulher","esposa"], dica:"Feminino de homem"},
  {he:"אִישׁ", tr:"ish", pt:["homem","marido"], dica:"Masculino adulto"},
  {he:"נָבִיא", tr:"navi", pt:["profeta"], dica:"Homem que fala por Deus"},
  {he:"מֶלֶךְ", tr:"melekh", pt:["rei"], dica:"Soberano do povo"},
  {he:"מַלְכָּה", tr:"malká", pt:["rainha"], dica:"Soberana do povo"},
  {he:"אֵם", tr:"em", pt:["mãe"], dica:"Progenitora feminina"},
  {he:"אָב", tr:"av", pt:["pai","ancestral"], dica:"Progenitor masculino"},
  {he:"תַּלְמִיד", tr:"talmid", pt:["discípulo","aluno"], dica:"Segue o mestre"},
  {he:"אָמַר", tr:"amar", pt:["disse","falar","falou","dizer"], dica:"Expressar palavras"},
  {he:"הָלַךְ", tr:"halakh", pt:["andou","andar","caminhou","caminhar"], dica:"Locomoção"},
  {he:"אָמְרוּ", tr:"amru", pt:["disseram","falaram"], dica:"Plural de disse"},
  {he:"שָׁמַע", tr:"shama", pt:["ouviu","ouvir"], dica:"Sentido de escutar"},
  {he:"יָשַׁב", tr:"yashav", pt:["sentou","assentar","habitou","morar","residir"], dica:"Ficar em um lugar"},
  {he:"אָכַל", tr:"akal", pt:["comeu","comer"], dica:"Ato de comer"},
  {he:"לָקַח", tr:"lakach", pt:["pegou","tomou","pegar","tomar"], dica:"Ato de tomar algo"},
  {he:"רָאָה", tr:"ra'ah", pt:["viu","ver"], dica:"Perceber com os olhos"},
  {he:"אֵת", tr:"et", pt:["com","junto de","com o"], dica:"Preposição - junto de"},
  {he:"בְּתוֹךְ", tr:"betoch", pt:["dentro","em meio a"], dica:"No interior de algo"},
  {he:"עִם", tr:"im", pt:["com"], dica:"Junto de"},
  {he:"עַל", tr:"al", pt:["sobre","em cima de","acima"], dica:"Em cima"},
  {he:"אֶל", tr:"el", pt:["para","até"], dica:"Direção, movimento"},
  {he:"לִפְנֵי", tr:"lifnei", pt:["antes de","diante de"], dica:"Antes no tempo ou espaço"},
  {he:"דָּבָר", tr:"davar", pt:["palavra","coisa","assunto"], dica:"O que se diz"},
  {he:"עִיר", tr:"ir", pt:["cidade"], dica:"Lugar urbano"},
  {he:"שָׁלוֹם", tr:"shalom", pt:["paz","bem-estar","segurança"], dica:"Desejo de paz"},
  {he:"שָׁנָה", tr:"shanah", pt:["ano"], dica:"Tempo de 12 meses"},
  {he:"מַיִם", tr:"mayim", pt:["água","águas"], dica:"Líquido essencial"},
  {he:"עֵין", tr:"ayin", pt:["olho","vista"], dica:"Sentido da visão"},
  {he:"יָד", tr:"yad", pt:["mão","poder"], dica:"Parte do corpo / poder", power:true}
];

let gameElements = []; // Estrutura de dados para elementos do mapa

// ======== Variáveis Globais para Three.js e Lógica do Jogo 3D ========
let scene, camera, renderer;
let playerMesh, playerVelocity; // playerVelocity para física simples (y)
let groundMesh;
let wordMeshes = [], vilaoMeshes = [], cruzMeshes = [];

// Parâmetros do jogador e física (valores de exemplo, ajustar conforme necessário)
const PLAYER_SPEED = 0.15; // Velocidade de movimento horizontal
const PLAYER_JUMP_POWER = 0.25;
const GRAVITY = 0.012;
const PLAYER_SIZE = { width: 1, height: 1.8, depth: 0.5 }; // Tamanho do jogador em unidades 3D
const GROUND_Y_POSITION = -PLAYER_SIZE.height / 2; // Para que a base do jogador toque o chão

// Estado do jogo e controles
let keys = {};
let points, wordsFound, vidas, brilho, gameOver, endGameType, challengeActive, currentWordIdx, challengeStartTime;
let challengeTimer = null, challengeTimeout = 16;

// --- Inicialização e Configuração do Mundo 3D ---
function setupMapElements() { // Mesma lógica para definir quais elementos estarão no jogo
  let shuffledWords = WORDS.filter(w=>!w.power).sort(()=>Math.random()-0.5);
  let yadsToAdd = 10, wordsToAdd = 30;
  let powerSpacing = 3, vilaoSpacing = 3, vilaoStart = 7;
  let elements = [], idx=0, yads=0, vilaos=0;
  for (let i=0; i<wordsToAdd; i++) {
    if (i && i%powerSpacing === 0 && yads<yadsToAdd) {
      elements.push({type:"power", wordObj:WORDS.find(w=>w.power)}); // Adiciona objeto da palavra de poder
      yads++;
    }
    if (i >= vilaoStart && (i-vilaoStart)%vilaoSpacing === 0) {
      elements.push({type:"vilao"});
      vilaos++;
    }
    elements.push({type:"word", wordObj:shuffledWords[idx%shuffledWords.length]});
    idx++;
  }
  gameElements = elements;
}

function startGame() {
  const canvas = document.getElementById("game");

  // 1. Cena
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x7dd3fc); // Cor de fundo similar ao 2D

  // 2. Câmera
  // Usaremos uma PerspectiveCamera para visão 3D.
  // O campo de visão (fov), aspect ratio, near e far definem o frustum da câmera.
  camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);
  camera.position.set(0, 2, 7); // Posição inicial da câmera (x, y, z)
  camera.lookAt(0, 0, 0); // Olhando para o centro da cena inicialmente

  // 3. Renderer
  renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
  renderer.setSize(canvas.width, canvas.height);
  renderer.shadowMap.enabled = true; // Habilitar sombras (opcional, pode ser custoso)

  // 4. Iluminação
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Luz ambiente suave
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Luz direcional (como o sol)
  directionalLight.position.set(5, 10, 7.5);
  directionalLight.castShadow = true; // Luz projeta sombras
  scene.add(directionalLight);

  // 5. Chão (Ground)
  const groundGeometry = new THREE.PlaneGeometry(1000, 100); // Um plano grande para o chão
  const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x222b3e, side: THREE.DoubleSide });
  groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
  groundMesh.rotation.x = -Math.PI / 2; // Rotacionar para ficar horizontal
  groundMesh.position.y = GROUND_Y_POSITION - PLAYER_SIZE.height / 2; // Ajustar para base do jogador
  groundMesh.receiveShadow = true;
  scene.add(groundMesh);

  // 6. Jogador (Player)
  const playerGeometry = new THREE.BoxGeometry(PLAYER_SIZE.width, PLAYER_SIZE.height, PLAYER_SIZE.depth);
  // Tentar carregar a imagem do personagem como textura (simplificado)
  const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0077ff }); // Cor azul se textura falhar
  try {
    const textureLoader = new THREE.TextureLoader();
    const playerTexture = textureLoader.load(charImgs[selectedChar -1] || charImgs[0]);
    playerMaterial.map = playerTexture;
    playerMaterial.needsUpdate = true;
  } catch (e) { console.warn("Textura do personagem não carregada:", e); }

  playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
  playerMesh.position.set(0, 0, 0); // Posição inicial do jogador
  playerMesh.castShadow = true;
  scene.add(playerMesh);

  playerVelocity = new THREE.Vector3(0, 0, 0); // (vx, vy, vz) - usaremos vy para pulo/gravidade

  // Inicializar estado do jogo
  points = 200;
  wordsFound = 0;
  vidas = 3;
  brilho = 0; // Poderia ser um efeito de emissão no material 3D
  gameOver = false;
  endGameType = "";
  challengeActive = false;
  updateLives();
  updatePoints();

  // Gerar posições dos elementos do jogo (palavras, vilões) em 3D
  generate3DPositions();

  // Redimensionar canvas e câmera se a janela mudar
  window.addEventListener('resize', onWindowResize, false);
  onWindowResize(); // Ajusta no início

  // Iniciar o loop do jogo
  gameLoop();
}

function generate3DPositions() {
  wordMeshes.forEach(mesh => scene.remove(mesh)); // Limpar meshes antigos
  vilaoMeshes.forEach(mesh => scene.remove(mesh));
  wordMeshes = [];
  viloes = []; // Array para lógica de vilões, não os meshes

  let currentX = 5; // Posição X inicial para o primeiro elemento
  const spacing = 4;  // Espaçamento entre elementos
  const elementY = 0; // Altura dos elementos em relação ao jogador
  const elementZ = 0; // Profundidade (para um jogo side-scroller 3D, Z pode ser fixo ou variar pouco)

  setupMapElements(); // Reutiliza a lógica para definir a sequência de gameElements

  gameElements.forEach(elData => {
    let mesh;
    const elSize = (elData.type === "power") ? 0.8 : 0.6; // Tamanho do cubo
    const geometry = new THREE.BoxGeometry(elSize, elSize, elSize);
    let material;

    if (elData.type === "word" || elData.type === "power") {
      material = new THREE.MeshStandardMaterial({
        color: elData.type === "power" ? 0xffff00 : 0xffa500, // Amarelo para poder, laranja para palavra
      });
      // TODO: Para mostrar o texto hebraico, precisaríamos criar uma textura com o texto
      // e aplicá-la a uma face do cubo, ou usar TextGeometry (mais complexo).
      // Por ora, apenas cubos coloridos.
      mesh = new THREE.Mesh(geometry, material);
      mesh.userData = { type: elData.type, wordObj: elData.wordObj, found: false };
      wordMeshes.push(mesh);
    } else if (elData.type === "vilao") {
      material = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Vermelho para vilão
      mesh = new THREE.Mesh(geometry, material);
      mesh.userData = { type: elData.type, alive: true, cooldown: 0 };
      // vilaoMeshes é uma lista de meshes, viloes é a lista de objetos para lógica
      vilaoMeshes.push(mesh);
      viloes.push({ mesh: mesh, alive: true, cooldown: 0, originalX: currentX }); // Adiciona referência ao mesh
    }

    if (mesh) {
      mesh.position.set(currentX, elementY, elementZ);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);
      currentX += spacing + Math.random() * 2; // Avança X para o próximo elemento
    }
  });
  // Define o "comprimento" do mundo para a câmera saber os limites
  worldLength = currentX + 10; // Um pouco além do último elemento
}

function onWindowResize() {
  const canvas = document.getElementById("game");
  let newWidth = Math.min(window.innerWidth - 10, 900);
  let newHeight = Math.max(320, Math.min(window.innerHeight - (isMobile() ? 180 : 120), 500));

  canvas.width = newWidth;
  canvas.height = newHeight;

  if (camera && renderer) {
    camera.aspect = newWidth / newHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(newWidth, newHeight);
  }
}


// --- LÓGICA DE MOVIMENTO E FÍSICA 3D ---
function updatePlayer() {
  // Movimento Horizontal (controlado por teclas/touch)
  let moveDirection = 0;
  if (keys["ArrowLeft"]) {
    moveDirection = -1;
    playerMesh.rotation.y = Math.PI; // Virar para a esquerda (opcional)
  }
  if (keys["ArrowRight"]) {
    moveDirection = 1;
    playerMesh.rotation.y = 0;      // Virar para a direita (opcional)
  }
  playerMesh.position.x += moveDirection * PLAYER_SPEED;

  // Pulo e Gravidade (Vertical)
  playerVelocity.y -= GRAVITY; // Aplicar gravidade
  playerMesh.position.y += playerVelocity.y; // Mover jogador verticalmente

  // Colisão com o chão
  const groundLevel = GROUND_Y_POSITION; // O jogador "afunda" metade da sua altura no chão
  if (playerMesh.position.y < groundLevel) {
    playerMesh.position.y = groundLevel;
    playerVelocity.y = 0;
    // player.onGround = true; // (Variável do seu código original, adaptar se necessário)
  }

  // Pulo (se a tecla "ArrowUp" estiver pressionada e o jogador estiver no chão)
  // (Precisa de uma flag `onGround` mais robusta para 3D)
  if (keys["ArrowUp"] && playerMesh.position.y <= groundLevel + 0.1) { // +0.1 para margem
    playerVelocity.y = PLAYER_JUMP_POWER;
  }

  // Atualizar posição da câmera para seguir o jogador
  // A câmera pode ter um "lag" suave ou seguir diretamente.
  // Aqui, ela segue diretamente em X e Z, com uma altura e distância fixas.
  camera.position.x = playerMesh.position.x;
  camera.position.y = playerMesh.position.y + 3; // Um pouco acima do jogador
  camera.position.z = playerMesh.position.z + 7; // Atrás do jogador
  camera.lookAt(playerMesh.position.x, playerMesh.position.y, playerMesh.position.z); // Olhar para o jogador

  // Limitar movimento do jogador aos "limites do mundo" (opcional)
  // playerMesh.position.x = Math.max(0, Math.min(playerMesh.position.x, worldLength - PLAYER_SIZE.width));
}

function checkCollisions3D() {
  if (challengeActive || !playerMesh) return;

  const playerBox = new THREE.Box3().setFromObject(playerMesh);

  // Colisão com Palavras
  wordMeshes.forEach((wordMesh, index) => {
    if (wordMesh.userData.found || !wordMesh.parent) return; // Se já achou ou removido da cena

    const wordBox = new THREE.Box3().setFromObject(wordMesh);
    if (playerBox.intersectsBox(wordBox)) {
      currentWordIdx = index; // Este índice precisa mapear para `gameElements` ou `WORDS`
                              // A estrutura de `wordMesh.userData.wordObj` já tem o objeto da palavra.

      if (wordMesh.userData.type === "power") {
        points += 100;
        brilho = 90; // TODO: Efeito visual de brilho em 3D
        updatePoints();
        wordMesh.userData.found = true;
        scene.remove(wordMesh); // Remover o mesh da cena
        // setTimeout(()=>{ brilho=0; },3000);
      } else {
        // Encontrar o índice original da palavra em WORDS para o desafio
        const originalWordIndex = WORDS.indexOf(wordMesh.userData.wordObj);
        if (originalWordIndex !== -1) {
            triggerChallenge(originalWordIndex); // Usa o índice global de WORDS
        } else {
            console.error("Não foi possível encontrar o objeto da palavra para o desafio.");
        }
      }
    }
  });

  // Colisão com Vilões
  vilaoMeshes.forEach((vilaoMesh) => {
    if (!vilaoMesh.userData.alive || !vilaoMesh.parent) return;

    const vilaoBox = new THREE.Box3().setFromObject(vilaoMesh);
    if (playerBox.intersectsBox(vilaoBox)) {
      if (vilaoMesh.userData.cooldown <= 0) {
        points -= 50;
        updatePoints();
        vilaoMesh.userData.cooldown = 50; // Tempo de invulnerabilidade do vilão após colisão
        brilho = 0;
        if (points < 0) {
          loseLife();
        }
      }
    }
    if (vilaoMesh.userData.cooldown > 0) vilaoMesh.userData.cooldown--;
  });

  // Colisão de Cruzes com Vilões
  cruzMeshes.forEach((cruzMesh) => {
    if (!cruzMesh.userData.active || !cruzMesh.parent) return;
    const cruzBox = new THREE.Box3().setFromObject(cruzMesh);

    vilaoMeshes.forEach((vilaoMesh) => {
      if (!vilaoMesh.userData.alive || !vilaoMesh.parent) return;
      const vilaoBox = new THREE.Box3().setFromObject(vilaoMesh);

      if (cruzBox.intersectsBox(vilaoBox)) {
        vilaoMesh.userData.alive = false;
        scene.remove(vilaoMesh); // Remover vilão
        cruzMesh.userData.active = false;
        scene.remove(cruzMesh); // Remover cruz
        // TODO: Adicionar pontuação por derrotar vilão, etc.
      }
    });
  });
}


function fireCruz() {
  if (points < 100 || !playerMesh) return;

  const cruzSize = 0.3;
  const cruzGeometry = new THREE.BoxGeometry(cruzSize, cruzSize * 2, cruzSize / 2); // Formato de cruz simples
  const cruzMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xccaa00 }); // Amarelo brilhante
  const cruzMesh = new THREE.Mesh(cruzGeometry, cruzMaterial);

  const direction = (playerMesh.rotation.y === 0) ? 1 : -1; // Direita ou Esquerda

  cruzMesh.position.copy(playerMesh.position);
  cruzMesh.position.x += direction * (PLAYER_SIZE.width / 2 + cruzSize); // Sai da frente do jogador
  cruzMesh.position.y += PLAYER_SIZE.height / 4; // Um pouco acima do centro do jogador

  const cruzSpeed = 0.3;
  cruzMesh.userData = {
    active: true,
    velocity: new THREE.Vector3(direction * cruzSpeed, 0, 0),
    lifeTime: 0,
    maxLifeTime: 100 // Quantos frames a cruz dura
  };

  scene.add(cruzMesh);
  cruzMeshes.push(cruzMesh);

  points -= 100;
  updatePoints();
}

function updateCruzes() {
  for (let i = cruzMeshes.length - 1; i >= 0; i--) {
    const cruz = cruzMeshes[i];
    if (!cruz.userData.active || !cruz.parent) {
      if (cruz.parent) scene.remove(cruz);
      cruzMeshes.splice(i, 1);
      continue;
    }

    cruz.position.add(cruz.userData.velocity);
    cruz.userData.lifeTime++;

    if (cruz.userData.lifeTime > cruz.userData.maxLifeTime ||
        cruz.position.x < -50 || cruz.position.x > worldLength + 50) { // Limites do mundo para a cruz
      cruz.userData.active = false;
    }
  }
}


// --- Funções de HUD, Vidas, Pontos (Mantidas com pequena adaptação para `wordMeshes`) ---
function updatePoints() {
  document.getElementById('scoreValue').textContent = Math.max(0, points);
}
function loseLife() {
  vidas--;
  updateLives();
  if (vidas > 0) {
    if(playerMesh) playerMesh.position.set(0, 0, 0); // Resetar posição do jogador (exemplo)
    camera.position.x = 0; // Resetar câmera
    points = 200;
    updatePoints();
  } else {
    gameOver = true; // Adicionado para parar o loop
    endGameType = "over";
    showEndModal();
  }
}
function updateLives() {
  let html = "";
  for (let i=0; i<vidas; i++) html += `<span class="lives-heart">♥</span>`;
  document.getElementById('lives').innerHTML = html;
}

// --- Lógica de Desafio de Palavra (Mantida, mas `currentWordIdx` agora refere-se ao índice em `wordMeshes` ou `WORDS`) ---
function triggerChallenge(wordIdxInWORDS) { // Agora recebe o índice global de WORDS
  challengeActive = true; usedHint = false;
  currentWordIdx = wordIdxInWORDS; // Armazena o índice global da palavra em WORDS

  document.getElementById('modal').classList.remove('hidden');
  document.getElementById('hebrewWord').textContent = WORDS[wordIdxInWORDS].he;
  document.getElementById('answerInput').value = "";
  document.getElementById('feedback').textContent = "";
  document.getElementById('hint').textContent = "";
  document.getElementById('answerInput').focus();
  document.getElementById('hintBtn').disabled = false;
  challengeStartTime = performance.now();
  let timerEl = document.getElementById('timer');
  timerEl.textContent = `Tempo: ${challengeTimeout.toFixed(1)}s`;
  let secondsElapsed = 0;
  clearInterval(challengeTimer);
  challengeTimer = setInterval(() => {
    let now = performance.now();
    secondsElapsed = (now - challengeStartTime)/1000;
    let left = Math.max(0, challengeTimeout - secondsElapsed);
    timerEl.textContent = `Tempo: ${left.toFixed(1)}s`;
    if (left <= 0) {
      clearInterval(challengeTimer);
      failChallenge();
    }
  }, 90);
}
document.getElementById('hintBtn').addEventListener('click', function() {
  if (challengeActive && !usedHint && currentWordIdx !== -1) {
    document.getElementById('hint').textContent = WORDS[currentWordIdx].dica || "Sem dica.";
    usedHint = true;
    this.disabled = true;
  }
});
document.getElementById('answerForm').addEventListener('submit', function(e){
  e.preventDefault();
  if (!challengeActive || currentWordIdx === -1) return;
  let answer = normalize(document.getElementById('answerInput').value);
  let word = WORDS[currentWordIdx]; // Usa o índice global
  let accepted = word.pt.some(t => normalize(t) === answer);
  if (accepted) {
    completeChallenge();
  } else {
    document.getElementById('feedback').textContent = "Tradução incorreta. Tente novamente!";
  }
});

function completeChallenge() {
  if (currentWordIdx === -1) return;
  let timeTaken = (performance.now() - challengeStartTime)/1000;
  let pts = Math.round(
    usedHint ?
    Math.max(10, 60 - 3.5*timeTaken) :
    Math.max(20, 100 - 5*timeTaken)
  );
  points += pts;
  wordsFound++; // Incrementa o contador de palavras encontradas no jogo

  // Marcar a palavra como encontrada no array `wordMeshes` (se necessário para lógica futura)
  // A remoção da cena já acontece em `checkCollisions3D`
  // Se `currentWordIdx` se refere a `wordMeshes`, então:
  // if (wordMeshes[currentWordIdx]) wordMeshes[currentWordIdx].userData.found = true;

  updatePoints();
  document.getElementById('feedback').textContent = usedHint
    ? `Correto! +${pts} pts (com dica)`
    : `Correto! +${pts} pts`;
  setTimeout(()=>{
    document.getElementById('modal').classList.add('hidden');
    challengeActive = false;
    checkWinCondition();
  }, 600);
  clearInterval(challengeTimer);
}

function failChallenge() {
  if (currentWordIdx === -1) return;
  document.getElementById('feedback').textContent = `Tempo esgotado! Resposta: ${WORDS[currentWordIdx].pt[0]}`;
  setTimeout(()=>{
    document.getElementById('modal').classList.add('hidden');
    challengeActive = false;
    // A palavra não é "encontrada" para pontuação, mas o desafio termina.
    // Pode-se decidir se o item desaparece do mapa ou não.
    // Para simplificar, vamos assumir que o jogador pode tentar novamente se esbarrar de novo.
    checkWinCondition(); // Verifica se todas as *outras* palavras foram coletadas
  }, 1200);
  clearInterval(challengeTimer);
}

function checkWinCondition() {
    // Verifica se todas as palavras não-poder foram coletadas e todos os vilões derrotados
    const totalNormalWords = gameElements.filter(el => el.type === "word").length;
    const totalViloes = gameElements.filter(el => el.type === "vilao").length;

    let collectedNormalWords = 0;
    wordMeshes.forEach(wm => {
        if (wm.userData.found && wm.userData.type === "word") {
            collectedNormalWords++;
        }
    });
    // Precisamos contar os vilões derrotados.
    // Isso pode ser feito verificando quantos meshes de vilões foram removidos
    // ou mantendo um contador separado.
    let viloesDerrotados = 0;
    vilaoMeshes.forEach(vm => {
      if(!vm.userData.alive && !vm.parent) viloesDerrotados++; // Se não está vivo E foi removido
    });
    // Simplificação: Contar quantos meshes de vilões ainda existem na cena
    // let viloesRestantes = vilaoMeshes.filter(vm => vm.parent !== null && vm.userData.alive).length;


    // Condição de vitória: todas as palavras normais coletadas E todos os vilões derrotados
    if (collectedNormalWords >= totalNormalWords && viloesDerrotados >= totalViloes) {
        gameOver = true;
        endGameType = "win";
        showEndModal();
    }
}


function showEndModal() {
  document.getElementById('endModal').classList.remove('hidden');
  if (endGameType==="win") {
    document.getElementById('endTitle').innerHTML = '<span class="hebrew">מַזָּל טוֹב</span>';
    document.getElementById('endMsg').textContent = "Parabéns, você venceu!";
  } else {
    document.getElementById('endTitle').textContent = "Game Over";
    document.getElementById('endMsg').textContent = "Tente novamente!";
  }
}

// --- GAMELOOP 3D ---
function gameLoop() {
  if (gameOver) return; // Para o loop se o jogo acabou

  requestAnimationFrame(gameLoop); // Chama o próximo frame

  if (!challengeActive) {
    updatePlayer();
    updateCruzes();
    checkCollisions3D(); // Lógica de colisão 3D
    // brilho = Math.max(0, brilho-1); // Adaptar efeito de brilho para 3D se necessário
  }

  if (renderer && scene && camera) {
    renderer.render(scene, camera); // Renderiza a cena 3D
  }
}

// --- CONTROLES (Mantidos, disparam flags em `keys` ou chamam funções como `fireCruz`) ---
document.addEventListener('keydown', function(e){
  if (["ArrowUp", "ArrowLeft", "ArrowRight"].includes(e.code)) keys[e.code] = true;
  if (e.code==="Space" && !challengeActive) fireCruz();
  if (challengeActive && e.code === "Escape") {
    document.getElementById('modal').classList.add('hidden');
    challengeActive = false;
    clearInterval(challengeTimer);
  }
});
document.addEventListener('keyup', function(e){
  if (["ArrowUp", "ArrowLeft", "ArrowRight"].includes(e.code)) keys[e.code] = false;
});

// Controles Touch (Lógica mantida)
if (document.getElementById('btnLeft')) {
  let btns = [
    {id: 'btnLeft', code: 'ArrowLeft'},
    {id: 'btnRight', code: 'ArrowRight'},
    {id: 'btnUp', code: 'ArrowUp'}
  ];
  btns.forEach(({id, code}) => {
    let btn = document.getElementById(id); let timer;
    btn.addEventListener('touchstart', function(e) {
      e.preventDefault(); keys[code] = true; timer = setInterval(()=>{ keys[code]=true; }, 80);
    }, {passive: false});
    btn.addEventListener('touchend', function(e) {
      e.preventDefault(); keys[code] = false; if (timer) clearInterval(timer);
    }, {passive: false});
    btn.addEventListener('touchcancel', function(e) { keys[code] = false; if (timer) clearInterval(timer); }, {passive: false});
  });
  let btnFire = document.getElementById('btnFire');
  btnFire.addEventListener('touchstart', function(e) {
    e.preventDefault(); if(!challengeActive) fireCruz();
  }, {passive: false});
}

// Ajuste inicial do canvas já é feito em `onWindowResize` que é chamado no `startGame`
// setupMapElements(); // Chamado dentro de generate3DPositions -> startGame

</script>
</body>
</html>
